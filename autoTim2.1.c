#pragma config(Sensor, port4,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port5,  middleLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port7,  rightLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port8,  bumperSensor,   sensorVexIQ_Touch)
#pragma config(Motor,  motor1,          RingHolder,    tmotorVexIQ, openLoop, encoder)
#pragma config(Motor,  motor2,          ringIntake,    tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          clawMotor,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          PivotMotor,    tmotorVexIQ, openLoop, encoder)
#pragma config(Motor,  motor11,         leftMotor,     tmotorVexIQ, openLoop, driveLeft, encoder)
#pragma config(Motor,  motor12,         rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int threshold = 80;
int lineSpeed = 75;
int fourSpeed = 75;
int alingSpeed = 25;
int railHeading = 90;
int scoreHeading = 272;
int bumpHeading = 0;
int coord[4] = {0, 45, 180, 90};
int x = 0;
int gyroValue;
int gyroError;

task fixDrift()
{
	int rate;
	int angle, lastAngle;
	lastAngle = 0;
	gyroError = 0;
	setGyroSensitivity(gyroSensor, gyroNormalSensitivity);
	resetGyro(gyroSensor);
	wait1Msec(1000);

	while(true)
	{
			rate = getGyroRate(gyroSensor);
			angle = getGyroDegrees(gyroSensor);

			if( abs( rate ) < 2)
			{
				if (angle != lastAngle)
					gyroError += lastAngle - angle;
		}
		lastAngle = angle;
		gyroValue = angle + gyroError;
		wait1Msec(1000);
	}
}
void allign(const int coords, const int speed)
{
	if(getGyroDegrees(gyroSensor) > coords)
	{
		setMotor(rightMotor, -speed);
		setMotor(leftMotor, speed);
		waitUntil(getGyroDegrees(gyroSensor) <= coords);
		stopMultipleMotors(rightMotor, leftMotor);
	}

	if(getGyroDegrees(gyroSensor) < coords)
	{
		setMotor(rightMotor, speed);
		setMotor(leftMotor, -speed);
		waitUntil(getGyroDegrees(gyroSensor) >= coords);
		stopMultipleMotors(rightMotor, leftMotor);
	}
}

task drive()
{
	startTask(fixDrift);
	int velot = (getMotorSpeed(leftMotor));
  if (getGyroDegrees(gyroSensor) < gyroValue)
	{
		setMotorSpeed(rightMotor, velot-5);
		waitUntil(getGyroDegrees(gyroSensor) >= gyroValue);
		setMultipleMotors(velot, leftMotor, rightMotor);
	}
	if (getGyroDegrees(gyroSensor) > gyroValue)
	{
		setMotorSpeed(leftMotor, velot-5);
		waitUntil(getGyroDegrees(gyroSensor) <= gyroValue);
		setMultipleMotors(velot, leftMotor, rightMotor);
	}
}


void leftSensorTracking(const int count, const int speed)
{
	int i=0;
	startTask(drive);
	while(i < count)
	{
		while(i < count-1)
		{
			if (getColorGrayscale(middleLightSensor) <= threshold)
			{
				i++;
				displayVariableValues(line2, i);
				displaySensorValues(line4, gyroSensor);
				waitUntil(getColorGrayscale(middleLightSensor) >= threshold);
			}
		}
		setMotorSpeed(leftMotor, speed/2);
		setMotorSpeed(rightMotor, speed/2);
		waitUntil(getColorGrayscale(middleLightSensor) <= threshold);
		i++;
	}
	stopTask(drive);
	stopTask(fixDrift);
	stopAllMotors();
}

void rightSensorTracking(const int count, const int speed)
{
	int i=0;
	startTask(drive);
	while(i < count)
	{
		while(i < count-1)
		{
			if (getColorGrayscale(rightLightSensor) <= threshold)
			{
				i++;
				displayVariableValues(line2, i);
				displaySensorValues(line4, gyroSensor);
				waitUntil(getColorGrayscale(rightLightSensor) >= threshold);
			}
		}
		setMotorSpeed(leftMotor, speed/2);
		setMotorSpeed(rightMotor, speed/2);
		waitUntil(getColorGrayscale(rightLightSensor) <= threshold);
		i++;
	}
	stopTask(drive);
	stopTask(fixDrift);
	stopAllMotors();
}


static void moveClaw(const int ecount, const int speed)
	{
		moveMotorTarget(clawMotor, ecount, speed);
		waitUntilMotorStop(clawMotor);
		stopMotor(clawMotor);
	}

static void fourWheelDrive(const int ecount, const int speed)
	{
	resetMotorEncoder(leftMotor);
	setMotor(leftMotor, speed);
	setMotor(rightMotor, speed);

	repeatUntil(getMotorEncoder(leftMotor) >= ecount)
  {
  	displayMotorValues(line2, leftMotor);
  }
  stopAllMotors();

}

static void backup(const int ecount, const int speed)
	{
	moveMotorTarget(leftMotor, ecount, speed);
	moveMotorTarget(rightMotor, ecount, speed);
	waitUntilMotorStop(leftMotor);
}


void changePosition(const int ecount, const int speed) {
		moveMotorTarget(RingHolder, ecount, speed);
		waitUntilMotorStop(RingHolder);
}

void dump(const int ecount, const int speed) {
	moveMotorTarget(PivotMotor, ecount, speed);
	waitUntilMotorStop(PivotMotor);
}


void setup()
{
		setMotorBrakeMode(clawMotor, motorCoast);
		setMotorBrakeMode(RingHolder, motorCoast);
		setMotorBrakeMode(ringIntake, motorCoast);
		setMotorBrakeMode(leftMotor, motorCoast);
		setMotorBrakeMode(rightMotor, motorCoast);
		setMotorBrakeMode(PivotMotor, motorCoast);
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(PivotMotor);
		resetMotorEncoder(RingHolder);
		resetMotorEncoder(clawMotor);
		resetMotorEncoder(ringIntake);
		resetGyro(gyroSensor);
}
task main()
{

//waitUntil(getBumperValue(bumperSensor) == 1);
//		setup();
//		setMultipleMotors(75, rightMotor, leftMotor);
//		displaySensorValues(line4, middleLightSensor);
//		leftSensorTracking(1, 85);
//		allign(30, alingSpeed);
//		fourWheelDrive(450, 50);
//		backup(-40, 50);
//		moveClaw(-150, 50);
//		backup(-250, 50);
//		moveClaw(150, 50);
//		allign(85, alingSpeed);
//		setMultipleMotors(-85, rightMotor, leftMotor);
//		leftSensorTracking(2, -85);
//		backup(-110, 75);
//		changePosition(180, 50);
//		dump(-1225, 75);
//		dump(1225, 75);

waitUntil(getBumperValue(bumperSensor) == 1);
		resetGyro(gyroSensor);
		setMultipleMotors(75, rightMotor, leftMotor);
		displaySensorValues(line4, middleLightSensor);
		leftSensorTracking(3, 85);
		allign(33, alingSpeed);
		fourWheelDrive(450, 50);
		backup(-40, 50);
		moveClaw(-150, 50);
		setMultipleMotors(-85, rightMotor, leftMotor);
		leftSensorTracking(1, -85);
		moveClaw(150, 50);
		allign(49, alingSpeed);
		setMultipleMotors(-85, rightMotor, leftMotor);
		rightSensorTracking(2, -85);
		backup(-130, 100);
		changePosition(180, 50);
		dump(-1225, 75);
		dump(1225, 75);

//waitUntil(getBumperValue(bumperSensor) == 1);
//		resetGyro(gyroSensor);
//		moveMotorTarget(RingHolder, 180, 50);
//		setMultipleMotors(75, rightMotor, leftMotor);
//		displaySensorValues(line4, middleLightSensor);
//		leftSensorTracking(5, 85);
//		allign(30, alingSpeed);
//		fourWheelDrive(450, 50);
//		backup(-40, 50);
//		moveClaw(-150, 50);
//		backup(-250, 50);
//		moveClaw(150, 50);
//		allign(85, alingSpeed);
//		setMultipleMotors(-85, rightMotor, leftMotor);
//		leftSensorTracking(2, -85);
//		backup(-110, 75);
//		changePosition(180, 50);
//		dump(-1225, 50);
	}
