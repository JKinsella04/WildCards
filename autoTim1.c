#pragma config(Sensor, port3,  middleLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port4,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port7,  rightLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port8,  bumperSensor,   sensorVexIQ_Touch)
#pragma config(Motor,  motor1,          RingHolder,    tmotorVexIQ, openLoop, encoder)
#pragma config(Motor,  motor2,          ringIntake,    tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          clawMotor,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          pivotMotor,    tmotorVexIQ, openLoop, encoder)
#pragma config(Motor,  motor11,         leftMotor,     tmotorVexIQ, openLoop, driveLeft, encoder)
#pragma config(Motor,  motor12,         rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 _  ___ _____ __   ___  ____   __        ___ _     _    ____              _
/ |/ _ \___  / /_ / _ \|  _ \  \ \      / (_) | __| |  / ___|__ _ _ __ __| |___
| | | | | / / '_ \ (_) | | | |  \ \ /\ / /| | |/ _` | | |   / _` | '__/ _` / __|
| | |_| |/ /| (_) \__, | |_| |   \ V  V / | | | (_| | | |__| (_| | | | (_| \__ \
|_|\___//_/  \___/  /_/|____/     \_/\_/  |_|_|\__,_|_ \____\__,_|_|  \__,_|___/
|  _ \ _ __ ___   __ _ _ __ __ _ _ __ ___  _ __ ___ (_)_ __   __ _
| |_) | '__/ _ \ / _` | '__/ _` | '_ ` _ \| '_ ` _ \| | '_ \ / _` |
|  __/| | | (_) | (_| | | | (_| | | | | | | | | | | | | | | | (_| |
|_|   |_|  \___/ \__, |_|  \__,_|_| |_| |_|_| |_| |_|_|_| |_|\__, |
                 |___/                                       |___/
*/
//By: Jack Kinsella, Scott Parker, Dylan Quinn, Julia Quinn, and Joe Durand



//Universal Variables(Variables used by tasks and functions)

int threshold = 80;
int alingSpeed = 25;
int coord[4] = {0, 45, 180, 90};
int gyroValue;
int gyroError;


/*
  _____         _         __        __     _   _
 |_   _|_ _ ___| | _____  \ \      / /__  | | | |___  ___
   | |/ _` / __| |/ / __|  \ \ /\ / / _ \ | | | / __|/ _ \
   | | (_| \__ \   <\__ \   \ V  V /  __/ | |_| \__ \  __/
   |_|\__,_|___/_|\_\___/    \_/\_/ \___|  \___/|___/\___|

*/
task fixDrift()
{
	int rate;
	int angle, lastAngle;
	lastAngle = 0;
	gyroError = 0;
	setGyroSensitivity(gyroSensor, gyroNormalSensitivity);
	resetGyro(gyroSensor);
	wait1Msec(1000);
		while(true)
		{
			rate = getGyroRate(gyroSensor);
			angle = getGyroDegrees(gyroSensor);

			if( abs( rate ) < 2)
			{
				if (angle != lastAngle)
					gyroError += lastAngle - angle;
		}
		lastAngle = angle;
		gyroValue = angle + gyroError;
		wait1Msec(1000);
	}
}

task drive()
{
	startTask(fixDrift);
	int velot = (getMotorSpeed(leftMotor));
  if (getGyroDegrees(gyroSensor) < gyroValue)
	{
		setMotorSpeed(rightMotor, velot-5);
		waitUntil(getGyroDegrees(gyroSensor) >= gyroValue);
		setMultipleMotors(velot, leftMotor, rightMotor);
	}
	if (getGyroDegrees(gyroSensor) > gyroValue)
	{
		setMotorSpeed(leftMotor, velot-5);
		waitUntil(getGyroDegrees(gyroSensor) <= gyroValue);
		setMultipleMotors(velot, leftMotor, rightMotor);
	}
}

task drive2()
{
	int velot = (getMotorSpeed(leftMotor));
  if (getGyroDegrees(gyroSensor) < gyroValue)
	{
		setMotorSpeed(rightMotor, velot-5);
		waitUntil(getGyroDegrees(gyroSensor) >= gyroValue);
		setMultipleMotors(velot, leftMotor, rightMotor);
	}
	if (getGyroDegrees(gyroSensor) > gyroValue)
	{
		setMotorSpeed(leftMotor, velot-5);
		waitUntil(getGyroDegrees(gyroSensor) <= gyroValue);
		setMultipleMotors(velot, leftMotor, rightMotor);
	}
}

/*
  _____           _          __   _____         _
 | ____|_ __   __| |   ___  / _| |_   _|_ _ ___| | _____
 |  _| | '_ \ / _` |  / _ \| |_    | |/ _` / __| |/ / __|
 | |___| | | | (_| | | (_) |  _|   | | (_| \__ \   <\__ \
 |_____|_| |_|\__,_|  \___/|_|     |_|\__,_|___/_|\_\___/

*/

/*
  _____                 _   _                  __        __     _   _
 |  ___|   _ _ __   ___| |_(_) ___  _ __  ___  \ \      / /__  | | | |___  ___
 | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|  \ \ /\ / / _ \ | | | / __|/ _ \
 |  _|| |_| | | | | (__| |_| | (_) | | | \__ \   \ V  V /  __/ | |_| \__ \  __/
 |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/    \_/\_/ \___|  \___/|___/\___|

*/
void allign(const int coords, const int speed)
{
	if(getGyroDegrees(gyroSensor) > coords)
	{
		setMotor(rightMotor, -speed);
		setMotor(leftMotor, speed);
		waitUntil(getGyroDegrees(gyroSensor) <= coords);
		stopMultipleMotors(rightMotor, leftMotor);
	}

	if(getGyroDegrees(gyroSensor) < coords)
	{
		setMotor(rightMotor, speed);
		setMotor(leftMotor, -speed);
		waitUntil(getGyroDegrees(gyroSensor) >= coords);
		stopMultipleMotors(rightMotor, leftMotor);
	}
}



void rightSensorTracking(const int count, const int speed)
{
	int i=0;
	startTask(drive);
	while(i < count)
	{
		while(i < count-1)
		{
			if (getColorGrayscale(middleLightSensor) <= threshold)
			{
				i++;
				displayVariableValues(line2, i);
				displaySensorValues(line4, gyroSensor);
				waitUntil(getColorGrayscale(middleLightSensor) >= threshold);
			}
		}
		setMotorSpeed(leftMotor, speed/2);
		setMotorSpeed(rightMotor, speed/2);
		waitUntil(getColorGrayscale(middleLightSensor) <= threshold);
		i++;
	}
	stopTask(drive);
	stopTask(fixDrift);
	stopAllMotors();
}

void aahSensorTracking(const int count, const int speed)
{
	int i=0;
	startTask(drive2);
	while(i < count)
	{
		while(i < count-1)
		{
			if (getColorGrayscale(rightLightSensor) <= threshold)
			{
				i++;
				displayVariableValues(line2, i);
				displaySensorValues(line4, gyroSensor);
				waitUntil(getColorGrayscale(rightLightSensor) >= threshold);
			}
		}
		setMotorSpeed(leftMotor, speed/2);
		setMotorSpeed(rightMotor, speed/2);
		waitUntil(getColorGrayscale(rightLightSensor) <= threshold);
		i++;
	}
	stopTask(drive2);
	setMultipleMotors(0,leftMotor, rightMotor);
}


void moveClaw(const int ecount, const int speed)
	{
		moveMotorTarget(clawMotor, ecount, speed);
		waitUntilMotorStop(clawMotor);
		stopMotor(clawMotor);
	}

void fourWheelDrive(const int ecount, const int speed)
	{
	resetMotorEncoder(leftMotor);
	setMotor(leftMotor, speed);
	setMotor(rightMotor, speed);

	repeatUntil(getMotorEncoder(leftMotor) >= ecount)
  {
  	displayMotorValues(line2, leftMotor);
  }
  stopAllMotors();

}

void backup(const int ecount, const int speed)
	{
	moveMotorTarget(leftMotor, ecount, speed);
	moveMotorTarget(rightMotor, ecount, speed);
	waitUntilMotorStop(leftMotor);
}


void changePosition(const int ecount, const int speed) {
		moveMotorTarget(RingHolder, ecount, speed);
		waitUntilMotorStop(RingHolder);
}

void dump(const int ecount, const int speed) {
	moveMotorTarget(pivotMotor, ecount, speed);
	waitUntilMotorStop(pivotMotor);
}


void setup()
{
		setMotorBrakeMode(clawMotor, motorBrake);
		setMotorBrakeMode(RingHolder, motorBrake);
		setMotorBrakeMode(ringIntake, motorBrake);
		setMotorBrakeMode(leftMotor, motorBrake);
		setMotorBrakeMode(rightMotor, motorBrake);
		setMotorBrakeMode(pivotMotor, motorBrake);
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(pivotMotor);
		resetMotorEncoder(RingHolder);
		resetMotorEncoder(clawMotor);
		resetMotorEncoder(ringIntake);
		resetGyro(gyroSensor);
}

/*
  _____           _          __   _____                 _   _
 | ____|_ __   __| |   ___  / _| |  ___|   _ _ __   ___| |_(_) ___  _ __  ___
 |  _| | '_ \ / _` |  / _ \| |_  | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 | |___| | | | (_| | | (_) |  _| |  _|| |_| | | | | (__| |_| | (_) | | | \__ \
 |_____|_| |_|\__,_|  \___/|_|   |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

*/

/*
  _____         _      __  __       _
 |_   _|_ _ ___| | __ |  \/  | __ _(_)_ __
   | |/ _` / __| |/ / | |\/| |/ _` | | '_ \
   | | (_| \__ \   <  | |  | | (_| | | | | |
   |_|\__,_|___/_|\_\ |_|  |_|\__,_|_|_|_|_|_                            _         _            _
  / /  _ \  ___ / _(_)_ __   ___  ___  | |_| |__   ___   _ __ ___   __ _(_)_ __   | |_ __ _ ___| | __
 | || | | |/ _ \ |_| | '_ \ / _ \/ __| | __| '_ \ / _ \ | '_ ` _ \ / _` | | '_ \  | __/ _` / __| |/ /
 | || |_| |  __/  _| | | | |  __/\__ \ | |_| | | |  __/ | | | | | | (_| | | | | | | || (_| \__ \   <
 | ||____/ \___|_| |_|_| |_|\___||___/  \__|_| |_|\___| |_| |_| |_|\__,_|_|_| |_|  \__\__,_|___/_|\_\
  \_\              _   _                      _           _ __
  / _| ___  _ __  | |_| |__   ___   _ __ ___ | |__   ___ | |\ \
 | |_ / _ \| '__| | __| '_ \ / _ \ | '__/ _ \| '_ \ / _ \| __| |
 |  _| (_) | |    | |_| | | |  __/ | | | (_) | |_) | (_) | |_| |
 |_|  \___/|_|     \__|_| |_|\___| |_|  \___/|_.__/ \___/ \__| |
                                                            /_/
*/

task main()
{
		displaySensorValues(line1, middleLightSensor);
		waitUntil(getBumperValue(bumperSensor) == 1);
		setup();
		setMultipleMotors(75, rightMotor, leftMotor);
		displaySensorValues(line4, middleLightSensor);
		rightSensorTracking(1, 75);
		allign(30, alingSpeed);
		fourWheelDrive(450, 75);
		backup(-30, 50);
		turnLeft(2, 50);
		moveClaw(-150, 50);
		setMultipleMotors(-85, rightMotor, leftMotor);
		rightSensorTracking(1, -85);
		moveClaw(150, 50);
		allign(33, alingSpeed);
		setMultipleMotors(-85, rightMotor, leftMotor);
		aahSensorTracking(2, -85);
		changePosition(180, 50);
		dump(-1050, 75);
		dump(1000, 75);
		backup(200, 75);
	}

/*
  _____           _          __   _____         _      __  __       _
 | ____|_ __   __| |   ___  / _| |_   _|_ _ ___| | __ |  \/  | __ _(_)_ __
 |  _| | '_ \ / _` |  / _ \| |_    | |/ _` / __| |/ / | |\/| |/ _` | | '_ \
 | |___| | | | (_| | | (_) |  _|   | | (_| \__ \   <  | |  | | (_| | | | | |
 |_____|_| |_|\__,_|  \___/|_|     |_|\__,_|___/_|\_\ |_|  |_|\__,_|_|_| |_|

*/
